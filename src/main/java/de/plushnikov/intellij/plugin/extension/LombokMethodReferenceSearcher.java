package de.plushnikov.intellij.plugin.extension;

import com.intellij.model.SymbolResolveResult;
import com.intellij.openapi.application.QueryExecutorBase;
import com.intellij.openapi.util.TextRange;
import com.intellij.psi.PsiAnnotation;
import com.intellij.psi.PsiClass;
import com.intellij.psi.PsiElement;
import com.intellij.psi.PsiMethod;
import com.intellij.psi.PsiNameValuePair;
import com.intellij.psi.PsiNewExpression;
import com.intellij.psi.PsiReference;
import com.intellij.psi.PsiReferenceBase;
import com.intellij.psi.PsiReturnStatement;
import com.intellij.psi.PsiStatement;
import com.intellij.psi.impl.source.tree.java.PsiNewExpressionImpl;
import com.intellij.psi.search.searches.MethodReferencesSearch;
import com.intellij.util.Processor;
import de.plushnikov.intellij.plugin.psi.LombokLightClassBuilder;
import de.plushnikov.intellij.plugin.psi.LombokLightMethodBuilder;
import lombok.Builder;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.Collection;

public class LombokMethodReferenceSearcher extends QueryExecutorBase<PsiReference, MethodReferencesSearch.SearchParameters> {

  public LombokMethodReferenceSearcher(boolean requireReadAction) {
    super(requireReadAction);
    System.out.println("LombokMethodReferenceSearcher(boolean)");
  }

  public LombokMethodReferenceSearcher() {
    System.out.println("LombokMethodReferenceSearcher()");
  }

  @Override
  public void processQuery(@NotNull MethodReferencesSearch.SearchParameters queryParameters, @NotNull Processor<? super PsiReference> consumer) {
    PsiMethod queryMethod = queryParameters.getMethod();
    LombokLightMethodBuilder lombokMethod = LombokLightMethodBuilder.getLightMethodBuilder(queryMethod);

    // Each Lombok-generated PsiMethod exists twice.
    // - Once as an instance of LombokLightMethodBuilder which is properly wired by to its containing class.
    // - Once as a degenerated instance of PsiMethodImpl which is built by LombokLightMethodBuilder and is not properly wired to its containing class

    if (lombokMethod == null) {
      // The method in the query is not generated by lombok. Let's leave it alone.
      // TODO: we actually should probably search for references in Builder classes also for non-lombok constructors.
      return;
    }

    if (queryMethod != lombokMethod) {
      // We replace the search for the degenerated PsiMethodImpl by a search for the rich LombokLightMethodBuilder
      // (but only the query is not already the LombokLightMethodBuilder, otherwise we'll cause an infinite loop)
      MethodReferencesSearch.SearchParameters newParameters = new MethodReferencesSearch.SearchParameters(
        lombokMethod,
        queryParameters.getScopeDeterminedByUser(),
        queryParameters.isStrictSignatureSearch(),
        queryParameters.getOptimizer());
      MethodReferencesSearch.search(newParameters).forEach(consumer);
    }

    // If the method is a constructor, we must also look into inner classes, hoping to find a constructor reference inside an @Builder class
    if (lombokMethod.isConstructor() && lombokMethod.getContainingClass() != null) {
      findConstructorReferencesInInnerClasses(lombokMethod, lombokMethod.getContainingClass(), consumer);
    }
  }

  private void findConstructorReferencesInInnerClasses(LombokLightMethodBuilder lombokConstructor, PsiClass containingClass, Processor<? super PsiReference> consumer) {
    PsiAnnotation builderAnnotation = containingClass.getAnnotation(Builder.class.getName());
    if (builderAnnotation == null) {
      return;
    }

    String builderClassName = containingClass.getName() + "Builder";
    String buildMethodName = "build";
    for (PsiNameValuePair att : builderAnnotation.getParameterList().getAttributes()) {
      if (att.getAttributeName().equals("builderClassName")) {
        builderClassName = att.getLiteralValue().isEmpty() ? builderClassName : att.getLiteralValue();

      } else if (att.getAttributeName().equals("buildMethodName")) {
        buildMethodName = att.getLiteralValue();
      }
    }

    for (PsiClass clazz : lombokConstructor.getContainingClass().getInnerClasses()) {
      if (!(clazz instanceof LombokLightClassBuilder) || !clazz.getName().equals(builderClassName)) {
        // not a lombok generated builder
        continue;
      }
      for (PsiMethod builderMethod : clazz.getMethods()) {
        if (builderMethod instanceof LombokLightMethodBuilder && builderMethod.getName().equals(buildMethodName)) {
          findConstructorReferenceInBuildMethod(lombokConstructor, (LombokLightMethodBuilder) builderMethod, consumer);
        }
      }
    }
  }

  private void findConstructorReferenceInBuildMethod(LombokLightMethodBuilder lombokConstructor, LombokLightMethodBuilder buildMethod, Processor<? super PsiReference> consumer) {
    for (PsiStatement statement : buildMethod.getBody().getStatements()) {
      if (statement instanceof PsiReturnStatement) {
        PsiNewExpression newExpression = (PsiNewExpression) ((PsiReturnStatement) statement).getReturnValue();
        PsiMethod resolvedConstructor = newExpression.resolveConstructor();
        if (resolvedConstructor == lombokConstructor) {
          consumer.process(new BuilderMethodReference(
            newExpression,
            new TextRange(3, 4),
            resolvedConstructor
          ));
        }
      }
    }
  }

  private static class BuilderMethodReference extends PsiReferenceBase {
    private final PsiMethod resolved;

    public BuilderMethodReference(@NotNull PsiElement element, TextRange rangeInElement, PsiMethod resolved) {
      super(element, rangeInElement);
      this.resolved = resolved;
    }

    @Nullable
    @Override
    public PsiElement resolve() {
      return resolved;
    }
  }
}
