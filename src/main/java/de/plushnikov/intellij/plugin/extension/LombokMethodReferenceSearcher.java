package de.plushnikov.intellij.plugin.extension;

import com.intellij.openapi.application.QueryExecutorBase;
import com.intellij.openapi.util.TextRange;
import com.intellij.psi.PsiClass;
import com.intellij.psi.PsiElement;
import com.intellij.psi.PsiMethod;
import com.intellij.psi.PsiNewExpression;
import com.intellij.psi.PsiReference;
import com.intellij.psi.PsiReferenceBase;
import com.intellij.psi.search.searches.MethodReferencesSearch;
import com.intellij.util.Processor;
import de.plushnikov.intellij.plugin.psi.LombokLightMethodBuilder;
import lombok.Builder;
import lombok.With;
import lombok.experimental.Wither;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

public class LombokMethodReferenceSearcher extends QueryExecutorBase<PsiReference, MethodReferencesSearch.SearchParameters> {

  public LombokMethodReferenceSearcher(boolean requireReadAction) {
    super(requireReadAction);
    System.out.println("LombokMethodReferenceSearcher(boolean)");
  }

  public LombokMethodReferenceSearcher() {
    System.out.println("LombokMethodReferenceSearcher()");
  }

  @Override
  public void processQuery(@NotNull MethodReferencesSearch.SearchParameters queryParameters, @NotNull Processor<? super PsiReference> consumer) {
    PsiMethod queryMethod = queryParameters.getMethod();
    LombokLightMethodBuilder lombokMethod = LombokLightMethodBuilder.getLightMethodBuilder(queryMethod);
    PsiMethod actualMethod = lombokMethod == null ? queryMethod : lombokMethod;

    // Each Lombok-generated PsiMethod exists twice.
    // - Once as an instance of LombokLightMethodBuilder which is properly wired by to its containing class.
    // - Once as a degenerated instance of PsiMethodImpl which is built by LombokLightMethodBuilder and is not properly wired to its containing class

    if (lombokMethod != null && queryMethod != lombokMethod) {
      // We replace the search for the degenerated PsiMethodImpl by a search for the rich LombokLightMethodBuilder
      // (but only the query is not already the LombokLightMethodBuilder, otherwise we'll cause an infinite loop)
      MethodReferencesSearch.SearchParameters newParameters = new MethodReferencesSearch.SearchParameters(
        lombokMethod,
        queryParameters.getScopeDeterminedByUser(),
        queryParameters.isStrictSignatureSearch(),
        queryParameters.getOptimizer());
      MethodReferencesSearch.search(newParameters).forEach(consumer);
    }


    if (shouldLookForConstructorReferences(actualMethod)) {
      findConstructorReferencesInClassMethods(actualMethod.getContainingClass(), actualMethod, consumer);
      findConstructorReferencesInInnerClasses(actualMethod.getContainingClass(), actualMethod, consumer);
    }
  }

  /**
   * If the method is a constructor, we must also look into class methods (it might be used in @With methods),
   * and inner classes (it might be used in @Builder methods). Note that @With and @Builder will use physical
   * constructors if available, so we have to look for constructor references even if the constructor is not
   * generated by lombok.
   * <p>
   * However, in order to avoid searching deep into method implementations for *each* Constructor reference search and
   * save a bit of CPU, we will only search for constructor references if the containing class is annotated with
   *
   * @Builder, @Wither or @With
   */
  private boolean shouldLookForConstructorReferences(PsiMethod constructor) {
    if (!constructor.isConstructor()) {
      return false;
    }

    PsiClass containingClass = constructor.getContainingClass();
    if (containingClass == null) {
      return false;
    }

    return containingClass.getAnnotation(Builder.class.getName()) != null
      || containingClass.getAnnotation(With.class.getName()) != null
      || containingClass.getAnnotation(Wither.class.getName()) != null;
  }

  private void findConstructorReferencesInInnerClasses(PsiClass containingClass, PsiMethod constructor, Processor<? super PsiReference> consumer) {
    for (PsiClass clazz : containingClass.getInnerClasses()) {
      findConstructorReferencesInClassMethods(clazz, constructor, consumer);
    }
  }

  private boolean findConstructorReferencesInClassMethods(PsiClass clazz, PsiMethod constructor, Processor<? super PsiReference> consumer) {
    for (PsiMethod method : clazz.getMethods()) {
      if (method instanceof LombokLightMethodBuilder) {
        // only look in the methods we have generated ourselves. Other methods are already indexed and the references they contain can
        // already be found by the native ReferenceSearch
        if (!reportConstructorReferencesInElement(method, constructor, consumer)) {
          return false;
        }
      }
    }
    return true;
  }

  private boolean reportConstructorReferencesInElement(PsiElement haystack, PsiMethod needle, Processor<? super PsiReference> consumer) {
    if (haystack instanceof PsiNewExpression) {
      PsiNewExpression newExpression = (PsiNewExpression) haystack;
      PsiMethod resolvedConstructor = newExpression.resolveConstructor();
      if (resolvedConstructor == needle) {
        consumer.process(new LombokConstructorReference<>(
          newExpression,
          new TextRange(3, 4),
          resolvedConstructor
        ));
      }
    }

    PsiElement[] children = haystack.getChildren();
    for (PsiElement child : children) {
      if (!reportConstructorReferencesInElement(child, needle, consumer)) {
        return false;
      }
    }

    return true;
  }

  private static class LombokConstructorReference<T extends PsiElement> extends PsiReferenceBase<T> {
    private final PsiMethod resolved;

    public LombokConstructorReference(@NotNull T element, TextRange rangeInElement, PsiMethod resolved) {
      super(element, rangeInElement);
      this.resolved = resolved;
    }

    @Nullable
    @Override
    public PsiElement resolve() {
      return resolved;
    }
  }
}
